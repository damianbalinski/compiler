- dopracowac algorytm zwracania wolnego rejestru, zwracac rejestr, ktory byc
  najdawniej uzywany

- przerzucic pamiec z powrotem po zwolnieniu rejestru

%delete http://matrix.umcs.lublin.pl/DOC/bison-doc/html/Destructor-Decl.html



{ printf("hello"); } {
                                reg_check($2);
                                $1.jump_first = jzero($2->reg, 0);
                                if ($2->type)
                                    $1.jump_end = jump(0);
                                $1.label_cmd = code_get_label();
                            } 

{ $1.label_end = code_get_label();
                            if ($2->type) {
                                code_modif($1.jump_first, $1.label_cmd-$1.jump_first);
                                code_modif($1.jump_end, $1.label_end-$1.jump_end);
                            } 
                            else {
                                code_modif($1.jump_first, $1.label_end-$1.jump_first);
                            }
                            reg_free($2->reg);
                            unit_free($2);
                        }

|   IF              {printf("if_0\n"); }
        condition   {printf("if_1\n"); }
    THEN            {printf("if_2\n"); }
        commands    {printf("if_3\n"); }
    ELSE            {printf("if_4\n"); }
        commands    {printf("if_5\n"); }
    ENDIF           {printf("if_6\n"); }

|   IF              {printf("fi_0\n"); }
        condition   {printf("fi_1\n"); }
    THEN            {printf("fi_2\n"); }
        commands    {printf("fi_3\n"); }
    ENDIF           {printf("fi_4\n"); }


    |   /*IF             { printf("asd"); }
        condition   { $1 = (struct lbs *) newlblrec(); }
    THEN            { printf("if_2\n"); }
        commands    { printf("if_3\n"); }
    ELSE            { printf("if_4\n"); }
        commands    { printf("if_5\n"); }
    ENDIF           { printf("if_6\n"); } */


|   IF              { $1 = (cond_type*)malloc(sizeof(cond_type)); }
    condition       {
                        reg_check($3);
                        $1->jump_first = jzero($3->reg, 0);
                        if ($3->type)
                            $1->jump_end = jump(0);
                        $1->label_cmd = code_get_label();
                    } 
    THEN commands    
    ENDIF           {   $1->label_end = code_get_label();
    ENDIF           {   $1->label_end = code_get_label();
                        if ($3->type) {
                            code_modif($1->jump_first, $1->label_cmd-$1->jump_first);
                            code_modif($1->jump_end, $1->label_end-$1->jump_end);
                        } 
                        else {
                            code_modif($1->jump_first, $1->label_end-$1->jump_first);
                        }
                        reg_free($3->reg);
                        unit_free($3);
                    }


|   IF              {   $1 = cond_alloc();                  }
    condition
    THEN
    commands
    ELSE
    commands
    ENDIF

|  FOR ID FROM value DOWNTO value DO commands ENDFOR



/* dzielenie: 2
 * rejestrow: --
 * zlozonosc: --
 */
int division2(int n, int d) {
    int r = n;
    int k = 1;
    int q = 0;

    do {
        d <<= 1;
        k <<= 1;
    } while (k <= n);
    // d >>= 1;
    // k >>= 1;

    while (k > 0) {

        // printf("k = %d\n", k);
        // printf("r = %d\n", r);
        // printf("d = %d\n", r);
        // printf("\n");

        r <<= 1;
        if (r-d >= 0) {
            q += k;
            r -= d;
        }
        k >>= 1;   
    }

    return q;
}